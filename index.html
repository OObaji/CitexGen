<!DOCTYPE html>
<html lang="en" class="">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Citex Question Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/docx@8.5.0/build/index.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        #landingCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }
        .output-block {
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        .copy-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: #4A5568;
            color: white;
            padding: 4px 8px;
            border-radius: 5px;
            font-size: 12px;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .output-container:hover .copy-btn {
            opacity: 1;
        }
        /* Dark Mode Toggle */
        .theme-switch-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .theme-switch {
            display: inline-block;
            height: 24px;
            position: relative;
            width: 48px;
        }
        .theme-switch input {
            display:none;
        }
        .slider {
            background-color: #ccc;
            bottom: 0;
            cursor: pointer;
            left: 0;
            position: absolute;
            right: 0;
            top: 0;
            transition: .4s;
        }
        .slider:before {
            background-color: #fff;
            bottom: 4px;
            content: "";
            height: 16px;
            left: 4px;
            position: absolute;
            transition: .4s;
            width: 16px;
        }
        input:checked + .slider {
            background-color: #4f46e5;
        }
        input:checked + .slider:before {
            transform: translateX(24px);
        }
        .slider.round {
            border-radius: 34px;
        }
        .slider.round:before {
            border-radius: 50%;
        }
        /* Multi-select styling */
        select[multiple] {
            height: 120px;
        }
        select[multiple] option {
            padding: 8px;
        }
    </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 text-gray-800 dark:text-gray-200 transition-colors duration-300">

    <!-- Landing Page -->
    <div id="landingPage" class="relative min-h-screen flex flex-col items-center justify-center text-center overflow-hidden p-4">
        <canvas id="landingCanvas"></canvas>
        <div class="z-10">
            <h1 class="text-5xl md:text-7xl font-bold text-white drop-shadow-lg">Welcome to Citex</h1>
            <p class="text-lg md:text-xl text-gray-200 mt-4 max-w-2xl mx-auto drop-shadow-md">
                Your intelligent assistant for mastering academic citations. Generate dynamic, style-specific questions to test and improve your referencing skills.
            </p>
            <button id="getStartedBtn" class="mt-8 bg-indigo-600 text-white font-bold py-3 px-8 rounded-lg shadow-lg hover:bg-indigo-700 focus:outline-none focus:ring-4 focus:ring-indigo-500/50 transform hover:scale-105 transition-all duration-300">
                Get Started
            </button>
        </div>
    </div>

    <!-- Generator Page -->
    <div id="generatorPage" class="hidden">
        <div class="container mx-auto p-4 sm:p-6 md:p-8 max-w-4xl">
            <header class="text-center mb-8 relative">
                <h1 id="homeTitle" class="text-4xl font-bold text-gray-900 dark:text-white cursor-pointer" title="Back to Home">Citex Question Generator</h1>
                <p class="text-md text-gray-600 dark:text-gray-400 mt-2">Create formatted questions for your learning app with ease.</p>
                <!-- Dark Mode Toggle -->
                <div class="absolute top-0 right-0 theme-switch-wrapper">
                    <svg class="w-6 h-6 text-yellow-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"></path></svg>
                    <label class="theme-switch" for="checkbox">
                        <input type="checkbox" id="checkbox" />
                        <div class="slider round"></div>
                    </label>
                    <svg class="w-6 h-6 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"></path></svg>
                </div>
            </header>

            <main class="bg-white dark:bg-gray-800 p-6 sm:p-8 rounded-2xl shadow-lg">
                
                <!-- Configuration Section -->
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
                    <div>
                        <label for="numQuestions" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Number of Questions</label>
                        <input type="number" id="numQuestions" value="5" min="1" max="20" class="w-full p-3 border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 rounded-lg shadow-sm focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 transition">
                    </div>
                    <div>
                        <label for="questionCategory" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Question Category</label>
                        <select id="questionCategory" class="w-full p-3 border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 rounded-lg shadow-sm focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 transition">
                            <option value="reference_list">Reference List Entry</option>
                            <option value="in_text">In-text Citation</option>
                        </select>
                    </div>
                    <div>
                        <label for="citationStyle" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Citation Style</label>
                        <select id="citationStyle" class="w-full p-3 border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 rounded-lg shadow-sm focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 transition">
                            <option value="apa7">APA 7</option>
                            <option value="mla9">MLA 9</option>
                            <option value="harvard">Harvard</option>
                            <option value="chicago">Chicago (NB)</option>
                            <option value="mhra">MHRA</option>
                        </select>
                    </div>
                    <div class="md:col-span-1">
                        <label for="sourceType" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Source Type (Ctrl/Cmd + Click for multiple)</label>
                        <select id="sourceType" multiple class="w-full p-3 border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 rounded-lg shadow-sm focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 transition">
                            <!-- Options will be populated dynamically -->
                        </select>
                    </div>
                    <div class="md:col-span-2">
                        <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Question Type</label>
                        <div class="mt-2 flex space-x-4">
                            <div class="flex items-center">
                                <input id="dndCheckbox" name="questionType" type="checkbox" checked class="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500">
                                <label for="dndCheckbox" class="ml-3 block text-sm font-medium text-gray-700 dark:text-gray-300">Drag and Drop</label>
                            </div>
                            <div class="flex items-center">
                                <input id="mcqCheckbox" name="questionType" type="checkbox" checked class="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500">
                                <label for="mcqCheckbox" class="ml-3 block text-sm font-medium text-gray-700 dark:text-gray-300">MCQ</label>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Generate Button -->
                <div class="text-center mb-8 flex gap-4 justify-center">
                    <button id="generateBtn" class="bg-indigo-600 text-white font-bold py-3 px-8 rounded-lg shadow-md hover:bg-indigo-700 focus:outline-none focus:ring-4 focus:ring-indigo-500/50 transform hover:-translate-y-0.5 transition-all duration-300">
                        Generate Questions
                    </button>
                    <button id="downloadBtn" class="bg-green-600 text-white font-bold py-3 px-8 rounded-lg shadow-md hover:bg-green-700 focus:outline-none focus:ring-4 focus:ring-green-500/50 transform hover:-translate-y-0.5 transition-all duration-300 hidden">
                        Download as Word
                    </button>
                </div>

                <!-- Output Section -->
                <div id="output" class="hidden space-y-6">
                    <div class="output-container relative">
                        <h3 class="text-xl font-semibold mb-2 text-gray-900 dark:text-white">Generated Questions</h3>
                        <div id="htmlOutput" class="p-4 bg-gray-900 text-gray-100 rounded-lg text-sm font-mono output-block"></div>
                        <button class="copy-btn" onclick="copyToClipboard('htmlOutput')">Copy</button>
                    </div>
                </div>
                  <!-- Message Box -->
                <div id="messageBox" class="hidden fixed top-5 right-5 text-white py-2 px-4 rounded-lg shadow-lg transition-opacity duration-300">
                    Copied to clipboard!
                </div>
            </main>
        </div>
    </div>

    <script>
        // Global variable to store the last generated questions for DOCX export
        let lastGeneratedQuestions = [];
        
        // --- Data for Generation ---
        const data = {
            authors: [
                { first: 'John', last: 'Smith' }, { first: 'Jane', last: 'Doe' }, { first: 'Mark', last: 'Johnson' }, { first: 'Emily', last: 'Davis' }, { first: 'David', last: 'Wilson' }, { first: 'Sarah', last: 'Taylor' }, { first: 'Chris', last: 'Evans' }, { first: 'Laura', last: 'White' }, { first: 'James', last: 'Brown' }, { first: 'Lisa', last: 'Hall' }
            ],
            editors: [ { first: 'Peter', last: 'Jones' }, { first: 'Linda', last: 'Harris' }, { first: 'Michael', last: 'Clark'}, { first: 'Susan', last: 'Miller' } ],
            bookTitles: [ 'The Social Fabric', 'Echoes of the Past', 'Digital Communities', 'Future Imperfect', 'Rethinking Society', 'Urban Labyrinths', 'The Quantum Moment', 'Coastal Ecology' ],
            chapterTitles: [ 'The role of media in modern politics', 'Case studies in digital ethics', 'The future of work', 'Migration patterns in the 21st century', 'AI and human creativity' ],
            journalTitles: [ 'Journal of Educational Technology', 'Cognitive Science Quarterly', 'Media Psychology Review', 'International Journal of Sociology', 'Environmental Science & Policy' ],
            articleTitles: [ 'Cognitive load in virtual reality learning', 'The persistence of online memory', 'User engagement in mobile apps', 'Cross-cultural communication barriers', 'The impact of microplastics on marine life' ],
            publisherLocations: [
                { publisher: 'Routledge', location: 'London' },
                { publisher: 'Penguin Press', location: 'New York' },
                { publisher: 'Sage Publications', location: 'Thousand Oaks, CA' },
                { publisher: 'MIT Press', location: 'Cambridge, MA' },
                { publisher: 'Oxford University Press', location: 'Oxford' },
                { publisher: 'Cambridge University Press', location: 'Cambridge' },
                { publisher: 'John Wiley & Sons', location: 'Hoboken, NJ' },
                { publisher: 'Palgrave Macmillan', location: 'London' }
            ],
            organizations: [ 'World Health Organization', 'Pew Research Center', 'United Nations', 'Doctors Without Borders', 'Amnesty International', 'The World Bank' ],
            webTitles: [ 'Global health observatory', 'The state of digital news', 'Sustainable development goals report', 'Annual human rights review', 'Global economic prospects' ],
            youtubeChannels: [ 'SciShow', 'Veritasium', 'CrashCourse', 'TED', 'National Geographic', 'SmarterEveryDay' ],
            youtubeVideoTitles: [ 'The Science of Laziness', 'What Is Quantum Computing?', 'The History of the Silk Road', 'How to Build a Habit', 'The Hidden World of Fungi' ],
            newspapers: ['The Guardian', 'The New York Times', 'The Wall Street Journal', 'Le Monde'],
            universities: ['University of Oxford', 'Harvard University', 'University of Cambridge', 'Stanford University'],
            archives: ['The National Archives, Kew', 'Library of Congress, Washington, D.C.', 'Bodleian Libraries, Oxford']
        };

        // Source types for "Reference List Entry" category
        const referenceListSources = [
            { value: 'book', text: 'Books' },
            { value: 'edited_book', text: 'Edited Books' },
            { value: 'journal', text: 'Journal Articles' },
            { value: 'website', text: 'Web Resources' },
            { value: 'book_chapter', text: 'Book Chapter' },
            { value: 'youtube', text: 'YouTube Video' },
            { value: 'newspaper', text: 'Newspaper Article (Chicago only)' }, // Specific to Chicago
            { value: 'primary_source', text: 'Primary Source (Chicago only)' }, // Specific to Chicago
            { value: 'thesis', text: 'Thesis (MHRA only)' } // Specific to MHRA
        ];

        // Source types for "In-text Citation" category
        const inTextSources = [
            { value: 'in_text_single', text: 'Single author' }, 
            { value: 'in_text_two', text: 'Two authors' }, 
            { value: 'in_text_three', text: 'Three authors' },
            { value: 'in_text_four_plus', text: 'More than 3 authors' }
        ];

        /**
         * Returns a random item from an array.
         * @param {Array} arr The array to pick from.
         * @returns {*} A random item from the array.
         */
        function getRandomItem(arr) {
            return arr[Math.floor(Math.random() * arr.length)];
        }

        /**
         * Shuffles an array in place.
         * @param {Array} array The array to shuffle.
         * @returns {Array} The shuffled array.
         */
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }
        
        /**
         * Formats a list of authors for use in scenario descriptions.
         * E.g., "John Smith", "John Smith and Jane Doe", "John Smith, Jane Doe, and Bob Johnson".
         * @param {Array<Object>} people An array of author objects {first: 'F', last: 'L'}.
         * @returns {string} The formatted list of names.
         */
        function formatScenarioNameList(people) {
            const names = people.map(p => `${p.first} ${p.last}`);
            if (names.length === 1) return names[0];
            if (names.length === 2) return names.join(' and ');
            return names.slice(0, -1).join(', ') + ', and ' + names.slice(-1);
        }

        /**
         * Function to show a message box (replaces alert/confirm).
         * @param {string} message The message to display.
         * @param {string} type The type of message ('success' or 'error').
         */
        function showMessageBox(message, type = 'success') {
            const messageBox = document.getElementById('messageBox');
            messageBox.textContent = message;
            // Remove previous type classes
            messageBox.classList.remove('bg-green-500', 'bg-red-500');
            // Add new type class
            if (type === 'error') {
                messageBox.classList.add('bg-red-500');
            } else {
                messageBox.classList.add('bg-green-500');
            }
            messageBox.classList.remove('hidden');
            setTimeout(() => {
                messageBox.classList.add('hidden');
            }, 3000); // Display for 3 seconds
        }

        /**
         * Removes HTML tags (<i>, <span> with underline) from a given text.
         * @param {string} text The text containing HTML tags.
         * @returns {string} The text with HTML tags removed.
         */
        function cleanHtmlTags(text) {
            // Ensure text is a string before calling replace
            const stringText = String(text);
            return stringText.replace(/<i>/g, '').replace(/<\/i>/g, '').replace(/<span style="text-decoration: underline;">/g, '').replace(/<\/span>/g, '');
        }

        /**
         * Dynamically updates the available source types based on the selected question category.
         */
        function updateSourceTypes() {
            const category = document.getElementById('questionCategory').value;
            const citationStyle = document.getElementById('citationStyle').value;
            const sourceDropdown = document.getElementById('sourceType');
            
            // Store current selected values to re-select if available in new list
            const currentSourceValues = Array.from(sourceDropdown.selectedOptions).map(opt => opt.value);
            
            sourceDropdown.innerHTML = ''; // Clear existing options
            
            let sources = [];
            if (category === 'in_text') {
                sources = inTextSources;
            } else { // 'reference_list'
                sources = referenceListSources.filter(source => {
                    if (source.value === 'newspaper' || source.value === 'primary_source') {
                        return citationStyle === 'chicago';
                    }
                    if (source.value === 'thesis') {
                        return citationStyle === 'mhra';
                    }
                    return true; // Include all other source types
                });
            }
            
            sources.forEach(source => {
                const option = document.createElement('option');
                option.value = source.value;
                option.textContent = source.text;
                // Re-select previously selected options if they exist in the new list
                if (currentSourceValues.includes(source.value)) {
                    option.selected = true;
                }
                sourceDropdown.appendChild(option);
            });

            // If no options are selected after update, select the first one
            if (sourceDropdown.selectedOptions.length === 0 && sources.length > 0) {
                 sourceDropdown.selectedIndex = 0;
            }
        }

        /**
         * Generates a set of citation questions based on user selections.
         */
        function generateQuestions() {
            const numQuestions = parseInt(document.getElementById('numQuestions').value) || 1;
            const citationStyle = document.getElementById('citationStyle').value;
            const selectedSourceTypes = Array.from(document.getElementById('sourceType').selectedOptions).map(opt => opt.value);
            const selectedQuestionTypes = [];
            if (document.getElementById('dndCheckbox').checked) selectedQuestionTypes.push('dnd');
            if (document.getElementById('mcqCheckbox').checked) selectedQuestionTypes.push('mcq');

            // Validate selections
            if (selectedSourceTypes.length === 0 || selectedQuestionTypes.length === 0) {
                showMessageBox("Please select at least one Source Type and one Question Type.", 'error');
                return;
            }

            let allQuestionsOutput = '';
            lastGeneratedQuestions = []; // Reset global array for DOCX export

            for (let i = 0; i < numQuestions; i++) {
                const sourceType = getRandomItem(selectedSourceTypes);
                const questionType = getRandomItem(selectedQuestionTypes);
                let questionData = {};
                
                // Map to retrieve the correct generation function based on style and source type
                const generatorMap = {
                    'apa7-book': () => generateApaBook(getRandomItem([1,2,3])), 'apa7-edited_book': () => generateApaEditedBook(getRandomItem([1,2])), 'apa7-journal': () => generateApaJournal(getRandomItem([1,2,3])), 'apa7-website': generateApaWebsite, 'apa7-book_chapter': generateApaBookChapter, 'apa7-youtube': generateApaYouTube, 'apa7-in_text_single': () => generateApaInText(1), 'apa7-in_text_two': () => generateApaInText(2), 'apa7-in_text_three': () => generateApaInText(3), 'apa7-in_text_four_plus': () => generateApaInText(4),
                    'mla9-book': () => generateMlaBook(getRandomItem([1,2,3])), 'mla9-edited_book': () => generateMlaEditedBook(getRandomItem([1,2])), 'mla9-journal': () => generateMlaJournal(getRandomItem([1,2,3])), 'mla9-book_chapter': generateMlaBookChapter, 'mla9-youtube': generateMlaYouTube, 'mla9-website': generateMlaWebsite, 'mla9-in_text_single': () => generateMlaInText(1), 'mla9-in_text_two': () => generateMlaInText(2), 'mla9-in_text_three': () => generateMlaInText(3), 'mla9-in_text_four_plus': () => generateMlaInText(4),
                    'harvard-book': () => generateHarvardBook(getRandomItem([1,2,3])), 'harvard-edited_book': () => generateHarvardEditedBook(getRandomItem([1,2])), 'harvard-journal': () => generateHarvardJournal(getRandomItem([1,2,3])), 'harvard-website': generateHarvardWebsite, 'harvard-book_chapter': generateHarvardBookChapter, 'harvard-youtube': generateHarvardYouTube, 'harvard-in_text_single': () => generateHarvardInText(1), 'harvard-in_text_two': () => generateHarvardInText(2), 'harvard-in_text_three': () => generateHarvardInText(3), 'harvard-in_text_four_plus': () => generateHarvardInText(4),
                    'chicago-book': () => generateChicagoBook(getRandomItem([1,2,3])), 'chicago-edited_book': () => generateChicagoEditedBook(getRandomItem([1,2])), 'chicago-journal': () => generateChicagoJournal(getRandomItem([1,2,3])), 'chicago-website': generateChicagoWebsite, 'chicago-book_chapter': generateChicagoBookChapter, 'chicago-newspaper': generateChicagoNewspaper, 'chicago-primary_source': generateChicagoPrimarySource, 'chicago-youtube': generateChicagoYouTube, 'chicago-in_text_single': () => generateChicagoInText(1), 'chicago-in_text_two': () => generateChicagoInText(2), 'chicago-in_text_three': () => generateChicagoInText(3), 'chicago-in_text_four_plus': () => generateChicagoInText(4),
                    'mhra-book': () => generateMhraBook(getRandomItem([1,2,3])), 'mhra-edited_book': () => generateMhraEditedBook(getRandomItem([1,2])), 'mhra-journal': () => generateMhraJournal(getRandomItem([1,2,3])), 'mhra-website': generateMhraWebsite, 'mhra-book_chapter': generateMhraBookChapter, 'mhra-thesis': () => generateMhraThesis, 'mhra-youtube': generateMhraYouTube, 'mhra-in_text_single': () => generateMhraInText(1), 'mhra-in_text_two': () => generateMhraInText(2), 'mhra-in_text_three': () => generateMhraInText(3), 'mhra-in_text_four_plus': () => generateMhraInText(4),
                };

                const generatorKey = `${citationStyle}-${sourceType}`;
                const generatorFunction = generatorMap[generatorKey];

                if (generatorFunction) {
                    try {
                        questionData = generatorFunction();
                    } catch (error) {
                        console.error(`Error generating question for ${citationStyle} - ${sourceType}:`, error);
                        showMessageBox(`Error generating question for ${citationStyle} - ${sourceType}. Please check the console for details.`, 'error');
                        // If an error occurs, skip this question and try to generate another one if there are more
                        if (numQuestions > 1 && i < numQuestions - 1) {
                            numQuestions--; // Adjust loop if a question cannot be generated
                            continue;
                        } else {
                            return; // Exit if no valid questions can be generated
                        }
                    }
                } else {
                    console.error("Generator function not found for key:", generatorKey);
                    // Skip this question and try to generate another one if there are more
                    if (numQuestions > 1 && i < numQuestions -1) {
                        numQuestions--; // Adjust loop if a question cannot be generated
                        continue; 
                    } else {
                        showMessageBox(`No generator found for ${citationStyle} - ${sourceType}. Please select different options.`, 'error');
                        return; // Exit if no valid questions can be generated
                    }
                }
                
                const sourceTypeText = document.querySelector(`#sourceType option[value='${sourceType}']`).textContent;
                const questionTypeText = questionType === 'dnd' ? 'Drag and Drop' : 'MCQ';
                const citationStyleText = document.getElementById('citationStyle').selectedOptions[0].text;
                // Removed question number from baseTitle
                questionData.baseTitle = `${sourceTypeText} - ${questionTypeText} - ${citationStyleText}`;

                let finalOutput;
                if (sourceType.startsWith('in_text')) {
                    finalOutput = questionType === 'mcq' ? convertToMcq(questionData, i + 1) : buildInTextDragAndDrop(questionData, i + 1);
                } else {
                    finalOutput = questionType === 'mcq' ? convertToMcq(questionData, i + 1) : buildDragAndDrop(questionData, i + 1);
                }
                
                const questionHeader = `Question ${i + 1}\n-----------------\n`;
                // Clean HTML tags from the final output before displaying and storing
                const cleanedQuestionText = cleanHtmlTags(questionHeader + finalOutput.htmlOutput);
                // Removed the .replace(/\|\|/g, '') from here
                allQuestionsOutput += cleanedQuestionText + '\n\n'; 
                // Removed the .replace(/\|\|/g, '') from here
                lastGeneratedQuestions.push(cleanedQuestionText); 
            }

            document.getElementById('htmlOutput').innerText = allQuestionsOutput;
            document.getElementById('output').classList.remove('hidden');
            document.getElementById('downloadBtn').classList.remove('hidden');
        }

        /**
         * Builds the text output for a Drag and Drop question (Reference List).
         * @param {Object} questionData The data for the question.
         * @param {number} questionNumber The current question number.
         * @returns {Object} An object containing the HTML output and original title.
         */
        function buildDragAndDrop(questionData, questionNumber) {
            const { baseTitle, scenario, fullReference, components, hint } = questionData;
            const title = `${baseTitle}`;
            
            const draggableCount = Math.max(2, Math.min(components.content.length - 1, Math.floor(Math.random() * (components.content.length - 1)) + 2));
            
            const allIndices = Array.from(Array(components.content.length).keys());
            const shuffledIndices = shuffleArray(allIndices);
            const draggableIndices = new Set(shuffledIndices.slice(0, draggableCount));

            const draggableItems = components.content.filter((_, i) => draggableIndices.has(i));
            
            let fixedPartsString = components.structure;
            allIndices.forEach(i => {
                const placeholder = `{${i}}`;
                if (draggableIndices.has(i)) {
                    fixedPartsString = fixedPartsString.replace(placeholder, '||');
                } else {
                    fixedPartsString = fixedPartsString.replace(placeholder, components.content[i]);
                }
            });

            // FIX: Remove periods that immediately follow a draggable placeholder to prevent outputs like '||. (2022)...'
            fixedPartsString = fixedPartsString.replace(/\|\|\s*\./g, '||');

            // NEW FIX: If the string starts with '||', replace it with a single '|'.
            if (fixedPartsString.trim().startsWith('||')) {
                fixedPartsString = fixedPartsString.replace(/^(\s*)\|\|/, '$1|');
            }

            // Randomly select only two distracting words
            const distractingWords = shuffleArray(components.distractors).slice(0, 2);

            const cleanedFixedPartsString = cleanHtmlTags(fixedPartsString);
            const cleanedFullReference = cleanHtmlTags(fullReference);

            const htmlOutput = `Question Title:\n${title}\n\nQuestion:\n${scenario}\n\nQuestion Parts (Correct Drag Items):\n${draggableItems.map(item => cleanHtmlTags(item)).join('\n')}\n\nFixed Parts:\n${cleanedFixedPartsString}\n\nConfusing Words (Distractor Drag Items):\n${distractingWords.map(item => cleanHtmlTags(item)).join('\n')}\n\nHint:\n${hint}`;

            return { htmlOutput: htmlOutput, originalTitle: questionData.originalTitle };
        }


        // --- APA 7 Generators ---
        function generateApaBook(numAuthors = 1) {
            const authors = [];
            while(authors.length < numAuthors) { const author = getRandomItem(data.authors); if (!authors.find(a => a.last === author.last)) authors.push(author); }
            const authorList = authors.map(a => `${a.last}, ${a.first.charAt(0)}.`);
            const authorString = authorList.length > 1 ? authorList.slice(0, -1).join(', ') + ', & ' + authorList.slice(-1) : authorList[0];
            const title = getRandomItem(data.bookTitles);
            const pubInfo = getRandomItem(data.publisherLocations);
            const publisher = pubInfo.publisher;
            const year = new Date().getFullYear() - Math.floor(Math.random() * 5);
            const scenario = `Reference for a book by ${formatScenarioNameList(authors)}, titled "${title}", published in ${year}.`;
            
            const components = {
                content: [ authorString, year, title, publisher ],
                structure: '{0} ({1}). <i>{2}</i>. {3}.',
                distractors: [ `${authors.map(a => `${a.last}, ${a.first}`).join(' & ')}`, `"${title}"`, `in press`, `${publisher}, ${year}` ]
            };
            const fullReference = components.structure
                .replace('{0}', components.content[0])
                .replace('{1}', components.content[1])
                .replace('{2}', components.content[2])
                .replace('{3}', components.content[3]);
            return { scenario, fullReference, components, hint: 'For a book reference in APA 7, the title of the book is italicized and written in sentence case.', originalTitle: title };
        }

        function generateApaEditedBook(numEditors = 1) {
            const editors = [];
            while(editors.length < numEditors) { const editor = getRandomItem(data.editors); if (!editors.find(e => e.last === editor.last)) editors.push(editor); }
            const editorList = editors.map(e => `${e.last}, ${e.first.charAt(0)}.`);
            const editorString = editorList.length > 1 ? editorList.slice(0, -1).join(', ') + ', & ' + editorList.slice(-1) : editorList[0];
            const title = getRandomItem(data.bookTitles);
            const pubInfo = getRandomItem(data.publisherLocations);
            const publisher = pubInfo.publisher;
            const year = new Date().getFullYear() - Math.floor(Math.random() * 5);
            const scenario = `Reference for an edited book titled "${title}", edited by ${formatScenarioNameList(editors)}, published in ${year}.`;
            const edLabel = numEditors > 1 ? '(Eds.).' : '(Ed.).';
            
            const components = {
                content: [ `${editorString}`, `${year}`, `${title}`, `${publisher}` ],
                structure: `{0} ${edLabel} ({1}). <i>{2}</i>. {3}.`,
                distractors: [ `${editorString} (ed.).`, `(Editors).`, `"${title}."`, `Published by ${publisher}` ]
            };
            const fullReference = components.structure
                .replace('{0}', components.content[0])
                .replace('{1}', components.content[1])
                .replace('{2}', components.content[2])
                .replace('{3}', components.content[3]);
            return { scenario, fullReference, components, hint: 'For an edited book, the editor\'s name is followed by (Ed.) for one editor or (Eds.) for multiple editors. The book title is italicized.', originalTitle: title };
        }

        function generateApaJournal(numAuthors = 1) {
            const authors = [];
            while(authors.length < numAuthors) { const author = getRandomItem(data.authors); if (!authors.find(a => a.last === author.last)) authors.push(author); }
            const authorList = authors.map(a => `${a.last}, ${a.first.charAt(0)}.`);
            const authorString = authorList.length > 1 ? authorList.slice(0, -1).join(', ') + ', & ' + authorList.slice(-1) : authorList[0];
            const articleTitle = getRandomItem(data.articleTitles);
            const journalTitle = getRandomItem(data.journalTitles);
            const year = new Date().getFullYear() - Math.floor(Math.random() * 3);
            const volume = Math.floor(Math.random() * 20) + 30;
            const issue = Math.floor(Math.random() * 4) + 1;
            const pages = `${Math.floor(Math.random() * 50) + 100}–${Math.floor(Math.random() * 10) + 150}`;
            const doi = `https://doi.org/10.1234/jet.${year}.${Math.floor(Math.random()*9000)+1000}`;
            const scenario = `Reference for the article "${articleTitle}" by ${formatScenarioNameList(authors)}, from ${journalTitle} (Vol. ${volume}), published in ${year}.`;

            const components = {
                content: [ `${authorString}`, `${year}`, `${articleTitle}`, `${journalTitle}`, `${volume}(${issue})`, `${pages}`, `${doi}` ],
                structure: '{0} ({1}). {2}. <i>{3}</i>, {4}, {5}. {6}',
                distractors: [ `'${articleTitle}'`, `${articleTitle}`, `pp. ${pages}`, `doi:${doi.replace('https://doi.org/','')}` ]
            };
            const fullReference = components.structure
                .replace('{0}', components.content[0])
                .replace('{1}', components.content[1])
                .replace('{2}', components.content[2])
                .replace('{3}', components.content[3])
                .replace('{4}', components.content[4])
                .replace('{5}', components.content[5])
                .replace('{6}', components.content[6]);
            return { scenario, fullReference, components, hint: 'In APA 7, the journal title and volume number are italicized. The article title is not.', originalTitle: journalTitle };
        }

        function generateApaWebsite() { 
            const org = getRandomItem(data.organizations);
            const title = getRandomItem(data.webTitles);
            const year = new Date().getFullYear();
            const month = new Date().toLocaleString('default', { month: 'long' });
            const day = new Date().getDate();
            const url = `https://www.${org.toLowerCase().replace(/\s/g, '')}.org/data/report`;

            const components = {
                content: [ `${org}`, `${year}, ${month} ${day}`, `${title}`, `${url}` ],
                structure: '{0}. ({1}). <i>{2}</i>. {3}',
                distractors: [ `${year}`, `"${title}"`, `Retrieved from ${url}`, `[accessed ${day} ${month} ${year}]` ]
            };
            const fullReference = components.structure
                .replace('{0}', components.content[0])
                .replace('{1}', components.content[1])
                .replace('{2}', components.content[2])
                .replace('{3}', components.content[3]);
            return { scenario, fullReference, components, hint: 'When a webpage has a specific publication date, include it in the reference. In APA 7, the title of a standalone webpage is italicized.', originalTitle: title };
        }

        function generateApaBookChapter() {
            const author = getRandomItem(data.authors);
            const editor = getRandomItem(data.editors);
            const chapterTitle = getRandomItem(data.chapterTitles);
            const bookTitle = getRandomItem(data.bookTitles);
            const pubInfo = getRandomItem(data.publisherLocations);
            const publisher = pubInfo.publisher;
            const year = new Date().getFullYear() - Math.floor(Math.random() * 5);
            const pages = `${Math.floor(Math.random() * 20) + 50}–${Math.floor(Math.random() * 10) + 70}`;
            const scenario = `Reference for the chapter "${chapterTitle}" by ${formatScenarioNameList([author])} from the book "${bookTitle}", edited by ${formatScenarioNameList([editor])}, published in ${year} by ${publisher}.`;

            const components = {
                content: [ `${author.last}, ${author.first.charAt(0)}.`, `${year}`, `${chapterTitle}`, `In ${editor.first.charAt(0)}. ${editor.last} (Ed.),`, `${bookTitle}`, `pp. ${pages}`, `${publisher}` ],
                structure: '{0} ({1}). {2}. {3} <i>{4}</i> ({5}). {6}.',
                distractors: [ `'${chapterTitle}'`, `ed. by ${editor.first} ${editor.last}`, `(pages ${pages})`, `In ${chapterTitle}` ]
            };
            const fullReference = components.structure
                .replace('{0}', components.content[0])
                .replace('{1}', components.content[1])
                .replace('{2}', components.content[2])
                .replace('{3}', components.content[3])
                .replace('{4}', components.content[4])
                .replace('{5}', components.content[5])
                .replace('{6}', components.content[6]);
            return { scenario, fullReference, components, hint: 'In APA 7, the book title is italicized, but the chapter title is not. The editor\'s name follows "In".', originalTitle: bookTitle };
        }

        function generateApaYouTube() { 
            const channel = getRandomItem(data.youtubeChannels);
            const title = getRandomItem(data.youtubeVideoTitles);
            const year = new Date().getFullYear() - Math.floor(Math.random() * 2);
            const month = new Date().toLocaleString('default', { month: 'long' });
            const day = new Date().getDate();
            const url = `https://www.youtube.com/watch?v=${Math.random().toString(36).substring(2, 13)}`;
            
            const components = {
                content: [ `${channel}`, `${year}, ${month} ${day}`, `${title}`, `YouTube`, `${url}` ],
                structure: '{0}. ({1}). <i>{2}</i> [Video]. {3}. {4}',
                distractors: [ `Uploaded by ${channel}`, `'${title}'`, `YouTube`, `Available at: ${url}` ]
            };
            const fullReference = components.structure
                .replace('{0}', components.content[0])
                .replace('{1}', components.content[1])
                .replace('{2}', components.content[2])
                .replace('{3}', components.content[3])
                .replace('{4}', components.content[4]);
            return { scenario, fullReference, components, hint: 'In APA 7, the title of the YouTube video is italicized. Include "[Video]" in brackets after the title.', originalTitle: title };
        }

        function generateApaInText(numAuthors) {
            const authors = [];
            while(authors.length < numAuthors) { const author = getRandomItem(data.authors); if (!authors.find(a => a.last === author.last)) authors.push(author); }
            const year = new Date().getFullYear() - Math.floor(Math.random() * 5);
            const page = Math.floor(Math.random() * 200) + 20;
            let authorString;
            if (numAuthors === 1) authorString = authors[0].last;
            else if (numAuthors === 2) authorString = `${authors[0].last} & ${authors[1].last}`;
            else authorString = `${authors[0].last} et al.`;
            
            const scenario = `In-text citation for a quote from page ${page} of a work by ${formatScenarioNameList(authors)}, published in ${year}. The citation goes here ||.`;
            const components = {
                correct: [`(${authorString}, ${year}, p. ${page})`],
                distractors: [ `(${authorString}, ${year})`, `(${authorString}, p. ${page})`, `(${authors[0].last}, ${year}, p. ${page})`, `(${authorString.replace('&', 'and')}, ${year}, p. ${page})` ]
            };
            return { scenario, fullReference: components.correct[0], components, hint: 'APA in-text citations for quotes require Author, Year, and Page Number. Use "&" for two authors and "et al." for three or more.', originalTitle: 'in-text' };
        }

        // --- MLA 9 Generators ---
        function generateMlaBook(numAuthors = 1) {
            const authors = [];
            while(authors.length < numAuthors) { const author = getRandomItem(data.authors); if (!authors.find(a => a.last === author.last)) authors.push(author); }
            let authorString;
            if (numAuthors === 1) {
                authorString = `${authors[0].last}, ${authors[0].first}`;
            } else if (numAuthors === 2) {
                authorString = `${authors[0].last}, ${authors[0].first}, and ${authors[1].first} ${authors[1].last}`;
            } else {
                 authorString = `${authors[0].last}, ${authors[0].first}, et al`;
            }
            const title = getRandomItem(data.bookTitles);
            const pubInfo = getRandomItem(data.publisherLocations);
            const publisher = pubInfo.publisher;
            const year = new Date().getFullYear() - Math.floor(Math.random() * 5);
            const scenario = `Reference for a book by ${formatScenarioNameList(authors)}, titled "${title}", published by ${publisher} in ${year}.`;
            
            const components = {
                content: [ `${authorString}`, `${title}`, `${publisher}`, `${year}` ],
                structure: '{0}. <i>{1}</i>. {2}, {3}.',
                distractors: [ `${authors[0].last}, ${authors[0].first.charAt(0)}.`, `(${year})`, `"${title}"`, `Published by ${publisher}` ]
            };
            const fullReference = components.structure
                .replace('{0}', components.content[0])
                .replace('{1}', components.content[1])
                .replace('{2}', components.content[2])
                .replace('{3}', components.content[3]);
            return { scenario, fullReference, components, hint: 'MLA style uses the author\'s full name and places the publication year at the very end. The book title is italicized.', originalTitle: title };
        }

        function generateMlaEditedBook(numEditors = 1) {
            const editors = [];
            while(editors.length < numEditors) { const editor = getRandomItem(data.editors); if (!editors.find(e => e.last === editor.last)) editors.push(editor); }
            let editorString;
            if (numEditors === 1) {
                editorString = `${editors[0].last}, ${editors[0].first}, editor`;
            } else {
                editorString = `${editors[0].last}, ${editors[0].first}, and ${editors[1].first} ${editors[1].last}, editors`;
            }
            const title = getRandomItem(data.bookTitles);
            const pubInfo = getRandomItem(data.publisherLocations);
            const publisher = pubInfo.publisher;
            const year = new Date().getFullYear() - Math.floor(Math.random() * 5);
            const scenario = `Reference for an edited book by ${formatScenarioNameList(editors)}, titled "${title}", published by ${publisher} in ${year}.`;
            
            const components = {
                content: [ `${editorString}`, `${title}`, `${publisher}`, `${year}` ],
                structure: '{0}. <i>{1}</i>. {2}, {3}.',
                distractors: [ `${editors.map(e => `${e.last}, ${e.first}`).join(' and ')} (Eds.)`, `"${title}"`, `(Editors)`, `${publisher}, ${year}` ]
            };
            const fullReference = components.structure
                .replace('{0}', components.content[0])
                .replace('{1}', components.content[1])
                .replace('{2}', components.content[2])
                .replace('{3}', components.content[3]);
            return { scenario, fullReference, components, hint: 'For an edited book in MLA, list the editor(s) name followed by "editor" or "editors". The book title is italicized.', originalTitle: title };
        }

        function generateMlaJournal(numAuthors = 1) {
            const authors = [];
            while(authors.length < numAuthors) { const author = getRandomItem(data.authors); if (!authors.find(a => a.last === author.last)) authors.push(author); }
            let authorString;
            if (numAuthors === 1) {
                authorString = `${authors[0].last}, ${authors[0].first}`;
            } else if (numAuthors === 2) {
                authorString = `${authors[0].last}, ${authors[0].first}, and ${authors[1].first} ${authors[1].last}`;
            } else {
                authorString = `${authors[0].last}, ${authors[0].first}, et al`;
            }
            const articleTitle = getRandomItem(data.articleTitles);
            const journalTitle = getRandomItem(data.journalTitles);
            const year = new Date().getFullYear() - Math.floor(Math.random() * 3);
            const volume = Math.floor(Math.random() * 20) + 30;
            const issue = Math.floor(Math.random() * 4) + 1;
            const pages = `${Math.floor(Math.random() * 50) + 100}-${Math.floor(Math.random() * 10) + 150}`;
            const scenario = `Reference for the article "${articleTitle}" by ${formatScenarioNameList(authors)} from ${journalTitle} (Vol. ${volume}), published in ${year}.`;

            const components = {
                content: [ `${authorString}`, `"${articleTitle}"`, `${journalTitle}`, `vol. ${volume}, no. ${issue}`, `${year}`, `pp. ${pages}` ],
                structure: '{0}. {1}. <i>{2}</i>, {3}, {4}, {5}.',
                distractors: [ `'${articleTitle}'`, `(${year})`, `Volume ${volume}, Issue ${issue}`, `pages ${pages}` ]
            };
            const fullReference = components.structure
                .replace('{0}', components.content[0])
                .replace('{1}', components.content[1])
                .replace('{2}', components.content[2])
                .replace('{3}', components.content[3])
                .replace('{4}', components.content[4])
                .replace('{5}', components.content[5]);
            return { scenario, fullReference, components, hint: 'In MLA 9, the article title is in quotes, and the journal title is italicized. For 3+ authors, use "et al.".', originalTitle: journalTitle };
        }

        function generateMlaWebsite() {
            const org = getRandomItem(data.organizations);
            const title = getRandomItem(data.webTitles);
            const year = new Date().getFullYear();
            const month = new Date().toLocaleString('default', { month: 'short' });
            const day = new Date().getDate();
            const url = `www.${org.toLowerCase().replace(/\s/g, '')}.org/data/report.html`;
            const scenario = `Reference for the webpage "${title}" from ${org}, published on ${day} ${month}. ${year}.`;
            
            const components = {
                content: [ `"${title}"`, `${org}`, `${day} ${month}. ${year}`, `${url}` ],
                structure: '{0}. <i>{1}</i>, {2}, {3}.',
                distractors: [ `${title}`, `${org}`, `(${year})`, `Available at: ${url}` ]
            };
            const fullReference = components.structure
                .replace('{0}', components.content[0])
                .replace('{1}', components.content[1])
                .replace('{2}', components.content[2])
                .replace('{3}', components.content[3]);
            return { scenario, fullReference, components, hint: 'In MLA 9, the article/page title is in quotes, and the overall website name is italicized.', originalTitle: org };
        }

        function generateMlaBookChapter() {
            const author = getRandomItem(data.authors);
            const editor = getRandomItem(data.editors);
            const chapterTitle = getRandomItem(data.chapterTitles);
            const bookTitle = getRandomItem(data.bookTitles);
            const pubInfo = getRandomItem(data.publisherLocations);
            const publisher = pubInfo.publisher;
            const year = new Date().getFullYear() - Math.floor(Math.random() * 5);
            const pages = `${Math.floor(Math.random() * 20) + 50}-${Math.floor(Math.random() * 10) + 70}`;
            const scenario = `Reference for the chapter "${chapterTitle}" by ${formatScenarioNameList([author])} from the edited book "${bookTitle}", edited by ${formatScenarioNameList([editor])}, published by ${publisher} in ${year}.`;

            const components = {
                content: [ `${author.last}, ${author.first}`, `"${chapterTitle}"`, `${bookTitle}`, `edited by ${editor.first} ${editor.last}`, `${publisher}`, `${year}`, `pp. ${pages}` ],
                structure: '{0}. {1}. <i>{2}</i>, {3}, {4}, {5}, {6}.',
                distractors: [ `'${chapterTitle}'`, `In ${bookTitle}`, `Editor, ${editor.first} ${editor.last}`, `pages ${pages}` ]
            };
            const fullReference = components.structure
                .replace('{0}', components.content[0])
                .replace('{1}', components.content[1])
                .replace('{2}', components.content[2])
                .replace('{3}', components.content[3])
                .replace('{4}', components.content[4])
                .replace('{5}', components.content[5])
                .replace('{6}', components.content[6]);
            return { scenario, fullReference, components, hint: 'In MLA 9, the chapter title is in quotes and the book title is italicized.', originalTitle: bookTitle };
        }

        function generateMlaYouTube() {
            const channel = getRandomItem(data.youtubeChannels);
            const title = getRandomItem(data.youtubeVideoTitles);
            const year = new Date().getFullYear() - Math.floor(Math.random() * 2);
            const month = new Date().toLocaleString('default', { month: 'short' });
            const day = new Date().getDate();
            const url = `www.youtube.com/watch?v=${Math.random().toString(36).substring(2, 13)}`;
            const scenario = `Reference for the YouTube video "${title}" from the channel ${channel}, uploaded on ${day} ${month}. ${year}.`;
            
            const components = {
                content: [ `"${title}"`, `YouTube`, `uploaded by ${channel}`, `${day} ${month}. ${year}`, `${url}` ],
                structure: '{0}. <i>{1}</i>, {2}, {3}, {4}.',
                distractors: [ `${title}`, `YouTube`, `[Video]`, `(${year})` ]
            };
            const fullReference = components.structure
                .replace('{0}', components.content[0])
                .replace('{1}', components.content[1])
                .replace('{2}', components.content[2])
                .replace('{3}', components.content[3])
                .replace('{4}', components.content[4]);
            return { scenario, fullReference, components, hint: 'In MLA 9, the video title is placed in quotation marks. The platform name (YouTube) is italicized.', originalTitle: 'YouTube' };
        }

        function generateMlaInText(numAuthors) {
            const authors = [];
            while(authors.length < numAuthors) { const author = getRandomItem(data.authors); if (!authors.find(a => a.last === author.last)) authors.push(author); }
            const year = new Date().getFullYear() - Math.floor(Math.random() * 5); // Define year here
            const page = Math.floor(Math.random() * 200) + 20;
            let authorString;
            if (numAuthors === 1) authorString = authors[0].last;
            else if (numAuthors === 2) authorString = `${authors[0].last} and ${authors[1].last}`;
            else authorString = `${authors[0].last} et al.`;
            
            const scenario = `In-text citation for a concept from page ${page} of a work by ${formatScenarioNameList(authors)}, published in ${year}. The paraphrase ends here ||.`;
            const components = {
                correct: [`(${authorString} ${page})`],
                distractors: [ `(${authorString}, ${page})`, `(${authorString}, p. ${page})`, `(${authors[0].last} ${page})`, `(${authorString})` ]
            };
            return { scenario, fullReference: components.correct[0], components, hint: 'MLA in-text citations require only the Author and Page Number inside the parentheses.', originalTitle: 'in-text' };
        }

        // --- Harvard Generators ---
        function generateHarvardBook(numAuthors = 1) {
            const authors = [];
            while(authors.length < numAuthors) { const author = getRandomItem(data.authors); if (!authors.find(a => a.last === author.last)) authors.push(author); }
            const authorList = authors.map(a => `${a.last}, ${a.first.charAt(0)}.`);
            const authorString = authorList.join(' and ');
            const title = getRandomItem(data.bookTitles);
            const pubInfo = getRandomItem(data.publisherLocations);
            const publisher = pubInfo.publisher;
            const location = pubInfo.location;
            const year = new Date().getFullYear() - Math.floor(Math.random() * 5);
            const scenario = `Reference for a book by ${formatScenarioNameList(authors)}, titled "${title}", published by ${publisher} in ${year}.`;

            const components = {
                content: [ `${authorString}`, `${year}`, `${title}`, `${location}: ${publisher}` ],
                structure: '{0} ({1}) <i>{2}</i>. {3}.',
                distractors: [ `${authors.map(a => `${a.last}, ${a.first}`).join(' and ')}`, `${year}`, `'${title}'`, `${publisher}, ${location}` ]
            };
            const fullReference = components.structure
                .replace('{0}', components.content[0])
                .replace('{1}', components.content[1])
                .replace('{2}', components.content[2])
                .replace('{3}', components.content[3]);
            return { scenario, fullReference, components, hint: 'In Harvard style, the year is in parentheses after the author\'s name. The book title is italicized.', originalTitle: title };
        }

        function generateHarvardEditedBook(numEditors = 1) {
            const editors = [];
            while(editors.length < numEditors) { const editor = getRandomItem(data.editors); if (!editors.find(e => e.last === editor.last)) editors.push(editor); }
            const editorList = editors.map(e => `${e.last}, ${e.first.charAt(0)}.`);
            const editorString = editorList.join(' and ');
            const title = getRandomItem(data.bookTitles);
            const pubInfo = getRandomItem(data.publisherLocations);
            const publisher = pubInfo.publisher;
            const location = pubInfo.location;
            const year = new Date().getFullYear() - Math.floor(Math.random() * 5);
            const edLabel = numEditors > 1 ? '(eds.)' : '(ed.)';
            const scenario = `Reference for an edited book by ${formatScenarioNameList(editors)}, titled "${title}", published by ${publisher} in ${year}.`;

            const components = {
                content: [ `${editorString}`, `${year}`, `${title}`, `${location}: ${publisher}` ],
                structure: `{0} ${edLabel} ({1}) <i>{2}</i>. {3}.`,
                distractors: [ `${editorString} (Editor)`, `${year}`, `"${title}"`, `${publisher}` ]
            };
            const fullReference = components.structure
                .replace('{0}', components.content[0])
                .replace('{1}', components.content[1])
                .replace('{2}', components.content[2])
                .replace('{3}', components.content[3]);
            return { scenario, fullReference, components, hint: 'For an entire edited book in Harvard style, the editor\'s name is followed by (ed.) or (eds.). The book title is italicized.', originalTitle: title };
        }

        function generateHarvardJournal(numAuthors = 1) {
            const authors = [];
            while(authors.length < numAuthors) { const author = getRandomItem(data.authors); if (!authors.find(a => a.last === author.last)) authors.push(author); }
            const authorList = authors.map(a => `${a.last}, ${a.first.charAt(0)}.`);
            let authorString;
            if (numAuthors <= 3) {
                authorString = authorList.join(' and ');
            } else {
                authorString = `${authorList[0]} et al.`;
            }
            const articleTitle = getRandomItem(data.articleTitles);
            const journalTitle = getRandomItem(data.journalTitles);
            const year = new Date().getFullYear() - Math.floor(Math.random() * 3);
            const volume = Math.floor(Math.random() * 20) + 30;
            const issue = Math.floor(Math.random() * 4) + 1;
            const pages = `${Math.floor(Math.random() * 50) + 100}-${Math.floor(Math.random() * 10) + 150}`;
            const scenario = `Reference for the article "${articleTitle}" by ${formatScenarioNameList(authors)} from ${journalTitle} (Vol. ${volume}), published in ${year}.`;

            const components = {
                content: [ `${authorString}`, `${year}`, `'${articleTitle}'`, `${journalTitle}`, `${volume}(${issue})`, `pp. ${pages}` ],
                structure: '{0} ({1}) {2}, <i>{3}</i>, {4}, {5}.',
                distractors: [ `"${articleTitle}"`, `${journalTitle}`, `vol. ${volume}, no. ${issue}`, `p. ${pages}` ]
            };
            const fullReference = components.structure
                .replace('{0}', components.content[0])
                .replace('{1}', components.content[1])
                .replace('{2}', components.content[2])
                .replace('{3}', components.content[3])
                .replace('{4}', components.content[4])
                .replace('{5}', components.content[5]);
            return { scenario, fullReference, components, hint: 'In Harvard style, the article title is in single quotes, while the journal title is italicized. Use \'et al.\' for more than three authors.', originalTitle: journalTitle };
        }

        function generateHarvardWebsite() {
            const org = getRandomItem(data.organizations);
            const title = getRandomItem(data.webTitles);
            const year = new Date().getFullYear();
            const url = `https://www.${org.toLowerCase().replace(/\s/g, '')}.org/data/report`;
            const date = new Date();
            const accessDate = `${date.getDate()} ${date.toLocaleString('default', { month: 'long' })} ${date.getFullYear()}`;
            const scenario = `Reference for the webpage "${title}" from ${org}, published in ${year}, accessed on ${accessDate}.`;
            
            const components = {
                content: [ `${org}`, `${year}`, `${title}`, `Available at: ${url}`, `(Accessed: ${accessDate})` ],
                structure: '{0} ({1}) <i>{2}</i>. {3} {4}.',
                distractors: [ `'${title}'`, `[online]`, `URL: ${url}`, `[accessed ${accessDate}]` ]
            };
            const fullReference = components.structure
                .replace('{0}', components.content[0])
                .replace('{1}', components.content[1])
                .replace('{2}', components.content[2])
                .replace('{3}', components.content[3])
                .replace('{4}', components.content[4]);
            return { scenario, fullReference, components, hint: 'Harvard style often requires an access date for online sources. The title of the webpage is italicized.', originalTitle: title };
        }

        function generateHarvardBookChapter() {
            const author = getRandomItem(data.authors);
            const editor = getRandomItem(data.editors);
            const chapterTitle = getRandomItem(data.chapterTitles);
            const bookTitle = getRandomItem(data.bookTitles);
            const pubInfo = getRandomItem(data.publisherLocations);
            const publisher = pubInfo.publisher;
            const location = pubInfo.location;
            const year = new Date().getFullYear() - Math.floor(Math.random() * 5);
            const pages = `${Math.floor(Math.random() * 20) + 50}-${Math.floor(Math.random() * 10) + 70}`;
            const scenario = `Reference for the chapter "${chapterTitle}" by ${formatScenarioNameList([author])} from the edited book "${bookTitle}", edited by ${formatScenarioNameList([editor])}, published by ${publisher} in ${year}.`;

            const components = {
                content: [ `${author.last}, ${author.first.charAt(0)}.`, `${year}`, `'${chapterTitle}'`, `in ${editor.last}, ${editor.first.charAt(0)}. (ed.)`, `${bookTitle}`, `${location}: ${publisher}`, `pp. ${pages}` ],
                structure: '{0} ({1}) {2}, {3} <i>{4}</i>. {5}, {6}.',
                distractors: [ `"${chapterTitle}"`, `In ${editor.first.charAt(0)}. ${editor.last} (Ed.)`, `${bookTitle}`, `pages ${pages}` ]
            };
            const fullReference = components.structure
                .replace('{0}', components.content[0])
                .replace('{1}', components.content[1])
                .replace('{2}', components.content[2])
                .replace('{3}', components.content[3])
                .replace('{4}', components.content[4])
                .replace('{5}', components.content[5])
                .replace('{6}', components.content[6]);
            return { scenario, fullReference, components, hint: 'In Harvard, chapter titles are in single quotes, while book titles are italicized. The editor\'s name is preceded by \'in\'.', originalTitle: bookTitle };
        }

        function generateHarvardYouTube() {
            const channel = getRandomItem(data.youtubeChannels);
            const title = getRandomItem(data.youtubeVideoTitles);
            const year = new Date().getFullYear() - Math.floor(Math.random() * 2);
            const url = `https://www.youtube.com/watch?v=${Math.random().toString(36).substring(2, 13)}`;
            const date = new Date();
            const accessDate = `${date.getDate()} ${date.toLocaleString('default', { month: 'long' })} ${date.getFullYear()}`;
            const scenario = `Reference for the YouTube video "${title}", uploaded by ${channel} in ${year}.`;
            
            const components = {
                content: [ `${channel}`, `${year}`, `${title}`, `YouTube video, added by ${channel}`, `Available at: ${url}`, `(Accessed: ${accessDate})` ],
                structure: '{0} ({1}) <i>{2}</i>. {3}. {4} {5}.',
                distractors: [ `'${title}'`, `[Video]`, `YouTube`, `[accessed ${accessDate}]` ]
            };
            const fullReference = components.structure
                .replace('{0}', components.content[0])
                .replace('{1}', components.content[1])
                .replace('{2}', components.content[2])
                .replace('{3}', components.content[3])
                .replace('{4}', components.content[4])
                .replace('{5}', components.content[5]);
            return { scenario, fullReference, components, hint: 'For YouTube videos in Harvard style, the title is italicized and you should include the platform name and an access date.', originalTitle: title };
        }

        function generateHarvardInText(numAuthors) {
            const authors = [];
            while(authors.length < numAuthors) { const author = getRandomItem(data.authors); if (!authors.find(a => a.last === author.last)) authors.push(author); }
            const year = new Date().getFullYear() - Math.floor(Math.random() * 5); // Define year here
            const page = Math.floor(Math.random() * 200) + 20;
            let authorString;
            if (numAuthors === 1) authorString = authors[0].last;
            else if (numAuthors <= 3) authorString = authors.map(a => a.last).join(' and ');
            else authorString = `${authors[0].last} et al.`;
            
            const scenario = `In-text citation for a quote from page ${page} of a work by ${formatScenarioNameList(authors)}, published in ${year}. The citation goes here ||.`;
            const components = {
                correct: [`(${authorString}, ${year}, p. ${page})`],
                distractors: [ `(${authorString} ${year}: ${page})`, `(${authorString}, p. ${page})`, `(${authors[0].last}, ${year}, page ${page})`, `(${authorString.replace('and', '&')}, ${year}, p. ${page})` ]
            };
            return { scenario, fullReference: components.correct[0], components, hint: 'Harvard in-text citations for quotes require Author, Year, and Page Number. Use "et al." for four or more authors.', originalTitle: 'in-text' };
        }

        // --- Chicago (NB) Generators ---
        function generateChicagoBook(numAuthors = 1) {
            const authors = [];
            while(authors.length < numAuthors) { const author = getRandomItem(data.authors); if (!authors.find(a => a.last === author.last)) authors.push(author); }
            const authorList = authors.map((a, i) => i === 0 ? `${a.last}, ${a.first}` : `${a.first} ${a.last}`);
            const authorString = authorList.join(', and ');
            const title = getRandomItem(data.bookTitles);
            const pubInfo = getRandomItem(data.publisherLocations);
            const publisher = pubInfo.publisher;
            const location = pubInfo.location;
            const year = new Date().getFullYear() - Math.floor(Math.random() * 5);
            const scenario = `Reference for a book by ${formatScenarioNameList(authors)}, titled "${title}", published by ${publisher} in ${year}.`;

            const components = {
                content: [ `${authorString}`, `${title}`, `${location}: ${publisher}`, `${year}` ],
                structure: '{0}. <i>{1}</i>. {2}, {3}.',
                distractors: [ `${authors.map(a => `${a.first} ${a.last}`).join(', ')}`, `(${year})`, `"${title}"`, `${publisher} (${location})` ]
            };
            const fullReference = components.structure
                .replace('{0}', components.content[0])
                .replace('{1}', components.content[1])
                .replace('{2}', components.content[2])
                .replace('{3}', components.content[3]);
            return { scenario, fullReference, components, hint: 'In a Chicago bibliography, the author\'s full name is used. The book title is italicized.', originalTitle: title };
        }

        function generateChicagoEditedBook(numEditors = 1) {
            const editors = [];
            while(editors.length < numEditors) { const editor = getRandomItem(data.editors); if (!editors.find(e => e.last === editor.last)) editors.push(editor); }
            const editorList = editors.map((e, i) => i === 0 ? `${e.last}, ${e.first}` : `${e.first} ${e.last}`);
            const editorString = editorList.join(' and ');
            const title = getRandomItem(data.bookTitles);
            const pubInfo = getRandomItem(data.publisherLocations);
            const publisher = pubInfo.publisher;
            const location = pubInfo.location;
            const year = new Date().getFullYear() - Math.floor(Math.random() * 5);
            const edLabel = numEditors > 1 ? 'eds.' : 'ed.';
            const scenario = `Reference for an edited book by ${formatScenarioNameList(editors)}, titled "${title}", published by ${publisher} in ${year}.`;

            const components = {
                content: [ `${editorString}, ${edLabel}`, `${title}`, `${location}: ${publisher}`, `${year}` ],
                structure: '{0}. <i>{1}</i>. {2}, {3}.',
                distractors: [ `${editors.map(e => `${e.first} ${e.last}`).join(', ')}, ${edLabel}`, `"${title}"`, `(Editor)`, `${publisher}, ${year}` ]
            };
            const fullReference = components.structure
                .replace('{0}', components.content[0])
                .replace('{1}', components.content[1])
                .replace('{2}', components.content[2])
                .replace('{3}', components.content[3]);
            return { scenario, fullReference, components, hint: 'For an entire edited book in Chicago, list the editor\'s name followed by "ed." or "eds.". The book title is italicized.', originalTitle: title };
        }

        function generateChicagoJournal(numAuthors = 1) {
            const authors = [];
            while(authors.length < numAuthors) { const author = getRandomItem(data.authors); if (!authors.find(a => a.last === author.last)) authors.push(author); }
            const authorList = authors.map((a, i) => i === 0 ? `${a.last}, ${a.first}` : `${a.first} ${a.last}`);
            const authorString = authorList.join(', and ');
            const articleTitle = getRandomItem(data.articleTitles);
            const journalTitle = getRandomItem(data.journalTitles);
            const year = new Date().getFullYear() - Math.floor(Math.random() * 3);
            const volume = Math.floor(Math.random() * 20) + 30;
            const issue = Math.floor(Math.random() * 4) + 1;
            const pages = `${Math.floor(Math.random() * 50) + 100}–${Math.floor(Math.random() * 10) + 150}`;
            const doi = `https://doi.org/10.1234/jet.${year}.${Math.floor(Math.random()*9000)+1000}`;
            const scenario = `Reference for the article "${articleTitle}" by ${formatScenarioNameList(authors)} from ${journalTitle} (Vol. ${volume}), published in ${year}.`;

            const components = {
                content: [ `${authorString}`, `"${articleTitle}"`, `${journalTitle} ${volume}, no. ${issue}`, `${year}`, `${pages}`, `${doi}` ],
                structure: '{0}. {1}. <i>{2}</i> ({3}): {4}. {5}.',
                distractors: [ `'${articleTitle}'`, `${journalTitle} vol. ${volume}`, `${year}`, `pp. ${pages}` ]
            };
            const fullReference = components.structure
                .replace('{0}', components.content[0])
                .replace('{1}', components.content[1])
                .replace('{2}', components.content[2])
                .replace('{3}', components.content[3])
                .replace('{4}', components.content[4])
                .replace('{5}', components.content[5]);
            return { scenario, fullReference, components, hint: 'In Chicago style, article titles are in quotes, and journal titles are italicized. The year is in parentheses after the volume/issue number.', originalTitle: journalTitle };
        }

        function generateChicagoWebsite() {
            const org = getRandomItem(data.organizations);
            const title = getRandomItem(data.webTitles);
            const year = new Date().getFullYear();
            const month = new Date().toLocaleString('default', { month: 'long' });
            const day = new Date().getDate();
            const url = `https://www.${org.toLowerCase().replace(/\s/g, '')}.org/data/report`;
            const scenario = `Reference for the webpage "${title}" from ${org}, last modified on ${month} ${day}, ${year}.`;

            const components = {
                content: [ `${org}`, `"${title}"`, `Last modified ${month} ${day}, ${year}`, `${url}` ],
                structure: '{0}. {1}. {2}. {3}.',
                distractors: [ `${title}`, `Published ${year}`, `Accessed ${month} ${day}, ${year}`, `Retrieved from: ${url}` ]
            };
            const fullReference = components.structure
                .replace('{0}', components.content[0])
                .replace('{1}', components.content[1])
                .replace('{2}', components.content[2])
                .replace('{3}', components.content[3]);
            return { scenario, fullReference, components, hint: 'For a Chicago bibliography entry, website article titles are in quotes. Use "Last modified" or a publication date if available.', originalTitle: title };
        }

        function generateChicagoBookChapter() {
            const author = getRandomItem(data.authors);
            const editor = getRandomItem(data.editors);
            const chapterTitle = getRandomItem(data.chapterTitles);
            const bookTitle = getRandomItem(data.bookTitles);
            const pubInfo = getRandomItem(data.publisherLocations);
            const publisher = pubInfo.publisher;
            const location = pubInfo.location;
            const year = new Date().getFullYear() - Math.floor(Math.random() * 5);
            const pages = `${Math.floor(Math.random() * 20) + 50}-${Math.floor(Math.random() * 10) + 70}`;
            const scenario = `Reference for the chapter "${chapterTitle}" by ${formatScenarioNameList([author])} from the edited book "${bookTitle}", edited by ${formatScenarioNameList([editor])}, published by ${publisher} in ${year}.`;

            const components = {
                content: [ `${author.last}, ${author.first}`, `"${chapterTitle}"`, `${bookTitle}`, `edited by ${editor.first} ${editor.last}`, `${pages}`, `${location}: ${publisher}, ${year}` ],
                structure: '{0}. {1}. In <i>{2}</i>, {3}, {4}. {5}.',
                distractors: [ `${chapterTitle}`, `In ${bookTitle}`, `(Ed. ${editor.first} ${editor.last})`, `pp. ${pages}` ]
            };
            const fullReference = components.structure
                .replace('{0}', components.content[0])
                .replace('{1}', components.content[1])
                .replace('{2}', components.content[2])
                .replace('{3}', components.content[3])
                .replace('{4}', components.content[4])
                .replace('{5}', components.content[5]);
            return { scenario, fullReference, components, hint: 'In Chicago, the chapter title is in quotes. The book title is italicized and preceded by "In".', originalTitle: bookTitle };
        }

        function generateChicagoNewspaper() {
            const author = getRandomItem(data.authors);
            const articleTitle = getRandomItem(data.articleTitles);
            const newspaper = getRandomItem(data.newspapers);
            const year = new Date().getFullYear() - Math.floor(Math.random() * 2);
            const month = new Date().toLocaleString('default', { month: 'long' });
            const day = new Date().getDate();
            const scenario = `Reference for the newspaper article "${articleTitle}" by ${formatScenarioNameList([author])} from ${newspaper}, published on ${month} ${day}, ${year}.`;

            const components = {
                content: [ `${author.last}, ${author.first}`, `"${articleTitle}"`, `${newspaper}`, `${month} ${day}, ${year}` ],
                structure: '{0}. {1}. <i>{2}</i>, {3}.',
                distractors: [ `'${articleTitle}'`, `Newspaper: ${newspaper}`, `(${year})`, `${author.first} ${author.last}` ]
            };
            const fullReference = components.structure
                .replace('{0}', components.content[0])
                .replace('{1}', components.content[1])
                .replace('{2}', components.content[2])
                .replace('{3}', components.content[3]);
            return { scenario, fullReference, components, hint: 'In Chicago style, the newspaper title is italicized, and the article title is in quotation marks.', originalTitle: newspaper };
        }

        function generateChicagoPrimarySource() {
            const author = getRandomItem(data.authors);
            const recipient = getRandomItem(data.authors);
            const year = Math.floor(Math.random() * 50) + 1880;
            const month = new Date(year, Math.floor(Math.random() * 12)).toLocaleString('default', { month: 'long' });
            const day = Math.floor(Math.random() * 28) + 1;
            const archive = getRandomItem(data.archives);
            const scenario = `Reference for the unpublished letter from ${formatScenarioNameList([author])} to ${formatScenarioNameList([recipient])}, dated ${month} ${day}, ${year}, and held at ${archive}.`;
            
            const components = {
                content: [ `${author.last}, ${author.first}`, `Letter to ${recipient.first} ${recipient.last}`, `${month} ${day}, ${year}`, `${archive}` ],
                structure: '{0}. {1}. {2}. {3}.',
                distractors: [ `${recipient.last}, ${recipient.first}`, `Personal correspondence`, `Dated ${year}`, `From the ${archive} collection` ]
            };
            const fullReference = components.structure
                .replace('{0}', components.content[0])
                .replace('{1}', components.content[1])
                .replace('{2}', components.content[2])
                .replace('{3}', components.content[3]);
            return { scenario, fullReference, components, hint: 'For unpublished letters in Chicago style, describe the item (e.g., "Letter to...") and list its date and location in an archive.', originalTitle: 'Letter' };
        }

        function generateChicagoYouTube() {
            const channel = getRandomItem(data.youtubeChannels);
            const title = getRandomItem(data.youtubeVideoTitles);
            const year = new Date().getFullYear() - Math.floor(Math.random() * 2);
            const month = new Date().toLocaleString('default', { month: 'long' });
            const day = new Date().getDate();
            const url = `https://www.youtube.com/watch?v=${Math.random().toString(36).substring(2, 13)}`;
            const scenario = `Reference for the YouTube video "${title}", uploaded by ${channel} on ${month} ${day}, ${year}.`;
            
            const components = {
                content: [ `${channel}`, `"${title}"`, `YouTube video`, `${Math.floor(Math.random() * 10)}:${Math.floor(Math.random() * 50 + 10)}`, `${month} ${day}, ${year}`, `${url}` ],
                structure: '{0}. {1}. {2}, {3}. {4}. {5}.',
                distractors: [ `${title}`, `Uploaded by ${channel}`, `[Video]`, `YouTube, ${year}` ]
            };
            const fullReference = components.structure
                .replace('{0}', components.content[0])
                .replace('{1}', components.content[1])
                .replace('{2}', components.content[2])
                .replace('{3}', components.content[3])
                .replace('{4}', components.content[4])
                .replace('{5}', components.content[5]);
            return { scenario, fullReference, components, hint: 'In Chicago style, the video title is in quotes. Include the platform, date, and URL.', originalTitle: title };
        }

        function generateChicagoInText(numAuthors) {
            const authors = [];
            while(authors.length < numAuthors) { const author = getRandomItem(data.authors); if (!authors.find(a => a.last === author.last)) authors.push(author); }
            const year = new Date().getFullYear() - Math.floor(Math.random() * 5);
            const page = Math.floor(Math.random() * 200) + 20;
            let authorString;
            if (numAuthors === 1) authorString = authors[0].last;
            else if (numAuthors <= 3) authorString = authors.map(a => a.last).join(' and ');
            else authorString = `${authors[0].last} et al.`;
            
            const scenario = `In-text citation for a quote from page ${page} of a work by ${formatScenarioNameList(authors)}, published in ${year}. The citation goes here ||.`;
            const components = {
                correct: [`(${authorString} ${year}, ${page})`],
                distractors: [ `(${authorString}, ${year}, p. ${page})`, `(${authorString} ${page})`, `(${authors[0].last}, ${year})`, `[${authorString} ${year}, ${page}]` ]
            };
            return { scenario, fullReference: components.correct[0], components, hint: 'A Chicago (Author-Date) in-text citation includes the Author, Year, and Page Number inside parentheses.', originalTitle: 'in-text' };
        }

        // --- MHRA Generators ---
        function generateMhraBook(numAuthors = 1) {
            const authors = [];
            while(authors.length < numAuthors) { const author = getRandomItem(data.authors); if (!authors.find(a => a.last === author.last)) authors.push(author); }
            const authorString = authors.map(a => `${a.last}, ${a.first}`).join(' and ');
            const title = getRandomItem(data.bookTitles);
            const pubInfo = getRandomItem(data.publisherLocations);
            const publisher = pubInfo.publisher;
            const location = pubInfo.location;
            const year = new Date().getFullYear() - Math.floor(Math.random() * 5);
            const scenario = `Reference for a book by ${formatScenarioNameList(authors)}, titled "${title}", published by ${publisher} in ${year}.`;
            
            const components = {
                content: [ `${authorString}`, `${title}`, `(${location}: ${publisher}, ${year})` ],
                structure: '{0}, <i>{1}</i> {2}',
                distractors: [ `${authors.map(a => `${a.first} ${a.last}`).join(' and ')}`, `"${title}"`, `${location}: ${publisher}, ${year}` ]
            };
            const fullReference = components.structure
                .replace('{0}', components.content[0])
                .replace('{1}', components.content[1])
                .replace('{2}', components.content[2]);
            return { scenario, fullReference, components, hint: 'In MHRA, the publication details (place, publisher, year) are enclosed in parentheses. The book title is italicized.', originalTitle: title };
        }

        function generateMhraEditedBook(numEditors = 1) {
            const editors = [];
            while(editors.length < numEditors) { const editor = getRandomItem(data.editors); if (!editors.find(e => e.last === editor.last)) editors.push(editor); }
            const editorString = editors.map(e => `${e.last}, ${e.first}`).join(' and ');
            const title = getRandomItem(data.bookTitles);
            const pubInfo = getRandomItem(data.publisherLocations);
            const publisher = pubInfo.publisher;
            const location = pubInfo.location;
            const year = new Date().getFullYear() - Math.floor(Math.random() * 5);
            const edLabel = numEditors > 1 ? 'eds,' : 'ed.,';
            const scenario = `Reference for an edited book by ${formatScenarioNameList(editors)}, titled "${title}", published by ${publisher} in ${year}.`;
            
            const components = {
                content: [ `${editorString}, ${edLabel}`, `${title}`, `(${location}: ${publisher}, ${year})` ],
                structure: '{0} <i>{1}</i> {2}',
                distractors: [ `${editorString}, (ed.)`, `"${title}"`, `${location}: ${publisher}, ${year}` ]
            };
            const fullReference = components.structure
                .replace('{0}', components.content[0])
                .replace('{1}', components.content[1])
                .replace('{2}', components.content[2]);
            return { scenario, fullReference, components, hint: 'For an entire edited book in MHRA, list the editor\'s name followed by "ed." or "eds.". The book title is italicized.', originalTitle: title };
        }

        function generateMhraJournal(numAuthors = 1) {
            const authors = [];
            while(authors.length < numAuthors) { const author = getRandomItem(data.authors); if (!authors.find(a => a.last === author.last)) authors.push(author); }
            const authorString = authors.map(a => `${a.last}, ${a.first}`).join(' and ');
            const articleTitle = getRandomItem(data.articleTitles);
            const journalTitle = getRandomItem(data.journalTitles);
            const year = new Date().getFullYear() - Math.floor(Math.random() * 3);
            const volume = Math.floor(Math.random() * 20) + 30;
            const issue = Math.floor(Math.random() * 4) + 1;
            const pages = `${Math.floor(Math.random() * 50) + 100}–${Math.floor(Math.random() * 10) + 150}`;
            const scenario = `Reference for the article "${articleTitle}" by ${formatScenarioNameList(authors)} from ${journalTitle} (Vol. ${volume}), published in ${year}.`;

            const components = {
                content: [ `${authorString}`, `'${articleTitle}'`, `${journalTitle}`, `${volume}.${issue} (${year})`, `${pages}` ],
                structure: '{0}, {1}, <i>{2}</i>, {3}, {4}',
                distractors: [ `"${articleTitle}"`, `Journal: ${journalTitle}`, `pp. ${pages}`, `(${year})` ]
            };
            const fullReference = components.structure
                .replace('{0}', components.content[0])
                .replace('{1}', components.content[1])
                .replace('{2}', components.content[2])
                .replace('{3}', components.content[3])
                .replace('{4}', components.content[4]);
            return { scenario, fullReference, components, hint: 'In MHRA, article titles are in single quotes, journal titles are italicized, and page ranges are not preceded by \'pp.\'.', originalTitle: journalTitle };
        }

        function generateMhraWebsite() {
            const org = getRandomItem(data.organizations);
            const title = getRandomItem(data.webTitles);
            const year = new Date().getFullYear();
            const url = `https://www.${org.toLowerCase().replace(/\s/g, '')}.org/data/report`;
            const date = new Date();
            const accessDate = `${date.getDate()} ${date.toLocaleString('default', { month: 'long' })} ${date.getFullYear()}`;
            const scenario = `Reference for the webpage "${title}" from ${org}, published in ${year}, accessed on ${accessDate}.`;
            
            const components = {
                content: [ `${org}`, `'${title}'`, `${year}`, `<${url}> [accessed ${accessDate}]` ],
                structure: '{0}, {1}, {2} <span style="text-decoration: underline;">{3}</span>',
                distractors: [ `${title}`, `(${year})`, `URL: ${url}`, `(Accessed: ${accessDate})` ]
            };
            const fullReference = components.structure
                .replace('{0}', components.content[0])
                .replace('{1}', components.content[1])
                .replace('{2}', components.content[2])
                .replace('{3}', components.content[3]);
            return { scenario, fullReference, components, hint: 'In MHRA, online article titles are in single quotes. The URL is enclosed in angle brackets, followed by the access date in square brackets.', originalTitle: title };
        }

        function generateMhraBookChapter() {
            const author = getRandomItem(data.authors);
            const editor = getRandomItem(data.editors);
            const chapterTitle = getRandomItem(data.chapterTitles);
            const bookTitle = getRandomItem(data.bookTitles);
            const pubInfo = getRandomItem(data.publisherLocations);
            const publisher = pubInfo.publisher;
            const location = pubInfo.location;
            const year = new Date().getFullYear() - Math.floor(Math.random() * 5);
            const pages = `${Math.floor(Math.random() * 20) + 50}-${Math.floor(Math.random() * 10) + 70}`;
            const scenario = `Reference for the chapter "${chapterTitle}" by ${formatScenarioNameList([author])} from the edited book "${bookTitle}", edited by ${formatScenarioNameList([editor])}, published by ${publisher} in ${year}.`;

            const components = {
                content: [ `${author.last}, ${author.first}`, `'${chapterTitle}'`, `${bookTitle}`, `ed. by ${editor.first} ${editor.last}`, `(${location}: ${publisher}, ${year})`, `pp. ${pages}` ],
                structure: '{0}, {1}, in <i>{2}</i>, {3} {4}, {5}',
                distractors: [ `"${chapterTitle}"`, `in ${chapterTitle}`, `(ed. ${editor.first} ${editor.last})`, `pages ${pages}` ]
            };
            const fullReference = components.structure
                .replace('{0}', components.content[0])
                .replace('{1}', components.content[1])
                .replace('{2}', components.content[2])
                .replace('{3}', components.content[3])
                .replace('{4}', components.content[4])
                .replace('{5}', components.content[5]);
            return { scenario, fullReference, components, hint: 'In MHRA, chapter titles are in single quotes, and book titles are italicized. The editor is introduced with \'ed. by\'.', originalTitle: bookTitle };
        }

        function generateMhraThesis() {
            const author = getRandomItem(data.authors);
            const title = getRandomItem(data.articleTitles); // Using articleTitles for generic thesis titles
            const university = getRandomItem(data.universities);
            const year = new Date().getFullYear() - Math.floor(Math.random() * 3);
            const scenario = `Reference for an unpublished PhD thesis titled "${title}" by ${formatScenarioNameList([author])}, from ${university} in ${year}.`;
            
            const components = {
                content: [ `${author.last}, ${author.first}`, `'${title}'`, `(unpublished PhD thesis, ${university}, ${year})` ],
                structure: '{0}, {1} {2}',
                distractors: [ `"${title}"`, `PhD dissertation`, `${university}`, `(${year})` ]
            };
            const fullReference = components.structure
                .replace('{0}', components.content[0])
                .replace('{1}', components.content[1])
                .replace('{2}', components.content[2]);
            return { scenario, fullReference, components, hint: 'In MHRA, thesis titles are in single quotes. The degree type, university, and year are enclosed in parentheses.', originalTitle: title };
        }

        function generateMhraYouTube() {
            const channel = getRandomItem(data.youtubeChannels);
            const title = getRandomItem(data.youtubeVideoTitles);
            const year = new Date().getFullYear() - Math.floor(Math.random() * 2);
            const url = `https://www.youtube.com/watch?v=${Math.random().toString(36).substring(2, 13)}`;
            const date = new Date();
            const accessDate = `${date.getDate()} ${date.toLocaleString('default', { month: 'long' })} ${date.getFullYear()}`;
            const scenario = `Reference for the YouTube video "${title}", uploaded by ${channel} in ${year}.`;
            
            const components = {
                content: [ `${channel}`, `'${title}'`, `YouTube`, `${year}`, `<${url}> [accessed ${accessDate}]` ],
                structure: '{0}, {1}, <i>{2}</i>, {3} <span style="text-decoration: underline;">{4}</span>',
                distractors: [ `"${title}"`, `YouTube Video`, `Uploaded by ${channel}`, `Accessed on ${accessDate}` ]
            };
            const fullReference = components.structure
                .replace('{0}', components.content[0])
                .replace('{1}', components.content[1])
                .replace('{2}', components.content[2])
                .replace('{3}', components.content[3])
                .replace('{4}', components.content[4]);
            return { scenario, fullReference, components, hint: 'In MHRA, the video title is in single quotes and the platform name (YouTube) is italicized. Include the URL and access date.', originalTitle: title };
        }

        function generateMhraInText(numAuthors) {
            // MHRA uses footnotes, not in-text citations in the same way as APA/Harvard. 
            // This is a simplified representation for quiz purposes.
            const authors = [];
            while(authors.length < numAuthors) { const author = getRandomItem(data.authors); if (!authors.find(a => a.last === author.last)) authors.push(author); }
            const year = new Date().getFullYear() - Math.floor(Math.random() * 5); // Define year here
            const page = Math.floor(Math.random() * 200) + 20;
            let authorString = authors.map(a => `${a.first} ${a.last}`).join(' and ');
            if (numAuthors > 3) authorString = `${authors[0].first} ${authors[0].last} and others`;
            
            const scenario = `Footnote for a work by ${formatScenarioNameList(authors)} (page ${page}), published in ${year}. The citation goes here ||.`;
            const components = {
                correct: [`${authorString}, p. ${page}`],
                distractors: [ `(${authorString}, p. ${page})`, `${authorString}, page ${page}`, `${authors[0].last}, p. ${page}` ]
            };
            return { scenario, fullReference: components.correct[0], components, hint: 'MHRA uses footnotes. A simplified footnote includes the author(s) name(s) and the page number preceded by "p.". No parentheses are used.', originalTitle: 'in-text' };
        }
        
        /**
         * Converts a generated question into a Multiple Choice Question format.
         * @param {Object} questionData The data for the question.
         * @param {number} questionNumber The current question number.
         * @returns {Object} An object containing the HTML output and original title.
         */
        function convertToMcq(questionData, questionNumber) {
            const { baseTitle, scenario, fullReference, hint, originalTitle, components } = questionData;
            const title = `${baseTitle}`;
            const correctRef = cleanHtmlTags(fullReference);

            let distractors = new Set();

            // Add pre-defined distractors, ensuring they are plain text and not identical to correctRef
            components.distractors.forEach(d => {
                const cleanedDistractor = cleanHtmlTags(d);
                if (cleanedDistractor !== correctRef && cleanedDistractor.trim() !== '') {
                    distractors.add(cleanedDistractor);
                }
            });

            // Generate more unique and plausible distractors until we have at least 3
            let attemptCount = 0;
            const maxAttempts = 20; // Prevent infinite loops
            const baseTransformations = [
                (s) => s.replace(/\./g, '___TEMP_DOT___').replace(/,/g, '.').replace(/___TEMP_DOT___/g, ','),
                (s) => s.replace(/\((.*?)\)/g, '[$1]').replace(/\[(.*?)\]/g, '($1)'),
                (s) => s.replace(/pp\. /g, '').replace(/p\. /g, ''),
                (s) => {
                    if (originalTitle && s.includes(originalTitle)) {
                        return s.replace(originalTitle, originalTitle.split(' ').map(word => {
                            if (word.length > 2) return word.charAt(0).toUpperCase() + word.slice(1);
                            return word;
                        }).join(' '));
                    }
                    return s;
                },
                (s) => {
                    const authorMatch = s.match(/^([^,]+), ([^,]+)/);
                    if (authorMatch) {
                        return `${authorMatch[2]}, ${authorMatch[1]}${s.substring(authorMatch[0].length)}`;
                    }
                    return s;
                },
                (s) => {
                    return s.replace(/(\(\d{4}\))/g, '').replace(/(\(\d{4}\.\))/g, '').trim();
                },
                (s) => {
                    if (s.match(/\d+–\d+/) && !s.includes('pp.') && !s.includes('p.')) return s.replace(/(\d+–\d+)/, 'pp. $1');
                    if (s.match(/\d+/) && !s.includes('pp.') && !s.includes('p.')) return s.replace(/(\d+)$/, 'p. $1');
                    return s;
                }
            ];

            while (distractors.size < 3 && attemptCount < maxAttempts) {
                let newDistractor = correctRef;
                const transformation = getRandomItem(baseTransformations);
                newDistractor = transformation(newDistractor);

                if (Math.random() < 0.3 && newDistractor.length < 150) {
                    const randomWord = getRandomItem(data.bookTitles).split(' ')[0];
                    if (!newDistractor.includes(randomWord)) {
                        const insertionPoint = Math.floor(Math.random() * newDistractor.length);
                        newDistractor = newDistractor.slice(0, insertionPoint) + ' ' + randomWord + ' ' + newDistractor.slice(insertionPoint);
                    }
                }

                const cleanedNewDistractor = cleanHtmlTags(newDistractor);
                if (cleanedNewDistractor !== correctRef && cleanedNewDistractor.trim() !== '' && !distractors.has(cleanedNewDistractor)) {
                    distractors.add(cleanedNewDistractor);
                }
                attemptCount++;
            }

            let optionsArray = Array.from(distractors);

            while (optionsArray.length < 3) {
                let fillerDistractor = getRandomItem(optionsArray);
                if (fillerDistractor.includes('.')) {
                    fillerDistractor = fillerDistractor.replace('.', ';');
                } else if (fillerDistractor.includes(',')) {
                    fillerDistractor = fillerDistractor.replace(',', '.');
                } else {
                    fillerDistractor += ' (alt)';
                }
                const cleanedFillerDistractor = cleanHtmlTags(fillerDistractor);
                if (cleanedFillerDistractor !== correctRef && cleanedFillerDistractor.trim() !== '' && !optionsArray.includes(cleanedFillerDistractor)) {
                    optionsArray.push(cleanedFillerDistractor);
                } else if (optionsArray.length < 2) {
                     optionsArray.push(cleanedFillerDistractor);
                }
            }

            if (optionsArray.length > 3) {
                optionsArray = shuffleArray(optionsArray).slice(0, 3);
            } else if (optionsArray.length < 3) {
                 while(optionsArray.length < 3) {
                     optionsArray.push(optionsArray[0] + ' (var)');
                 }
            }


            optionsArray = shuffleArray(optionsArray);
            
            let optionsString = '';
            for (let i = 0; i < optionsArray.length; i++) {
                optionsString += `${optionsArray[i]}\n`;
            }

            const mcqHtml = `Question Title:\n${title} (MCQ)\n\nQuestion:\n${scenario}\n\nCorrect Answer:\n${correctRef}\n\nOptions:\n${optionsString}\nHint/Explanation:\n${hint}`;
            
            return { htmlOutput: mcqHtml, originalTitle: originalTitle };
        }

        // --- Event Listeners & Page Setup ---
        document.addEventListener('DOMContentLoaded', () => {
            const landingPage = document.getElementById('landingPage');
            const generatorPage = document.getElementById('generatorPage');
            const getStartedBtn = document.getElementById('getStartedBtn');
            const homeTitle = document.getElementById('homeTitle');

            if (localStorage.getItem('currentPage') === 'generator') {
                landingPage.style.display = 'none';
                generatorPage.style.display = 'block';
            }

            getStartedBtn.addEventListener('click', () => {
                localStorage.setItem('currentPage', 'generator');
                landingPage.style.transition = 'opacity 0.5s';
                landingPage.style.opacity = '0';
                setTimeout(() => {
                    landingPage.style.display = 'none';
                    generatorPage.style.display = 'block';
                    generatorPage.style.opacity = '0';
                    setTimeout(() => {
                        generatorPage.style.transition = 'opacity 0.5s';
                        generatorPage.style.opacity = '1';
                    }, 50);
                }, 500);
            });
            
            homeTitle.addEventListener('click', () => {
                localStorage.removeItem('currentPage');
                window.location.reload();
            });

            const toggle = document.getElementById('checkbox');
            const html = document.documentElement;

            const currentTheme = localStorage.getItem('theme');
            if (currentTheme === 'dark' || (!currentTheme && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
                html.classList.add('dark');
                toggle.checked = true;
            }

            toggle.addEventListener('change', () => {
                if (toggle.checked) {
                    html.classList.add('dark');
                    localStorage.setItem('theme', 'dark');
                } else {
                    html.classList.remove('dark');
                    localStorage.setItem('theme', 'light');
                }
            });

            document.getElementById('generateBtn').addEventListener('click', generateQuestions);
            document.getElementById('downloadBtn').addEventListener('click', generateDocx);
            
            document.getElementById('questionCategory').addEventListener('change', () => {
                updateSourceTypes();
                generateQuestions();
            });
            document.getElementById('citationStyle').addEventListener('change', () => {
                updateSourceTypes();
                generateQuestions();
            });
            document.getElementById('sourceType').addEventListener('change', generateQuestions);
            document.getElementById('numQuestions').addEventListener('change', generateQuestions);
            document.getElementById('dndCheckbox').addEventListener('change', generateQuestions);
            document.getElementById('mcqCheckbox').addEventListener('change', generateQuestions);


            updateSourceTypes();
            generateQuestions();

            const canvas = document.getElementById('landingCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            let particlesArray;

            const mouse = {
                x: null,
                y: null,
                radius: (canvas.height/120) * (canvas.width/120)
            };

            window.addEventListener('mousemove', (event) => {
                mouse.x = event.x;
                mouse.y = event.y;
            });

            class Particle {
                constructor(x, y, directionX, directionY, size, color) {
                    this.x = x;
                    this.y = y;
                    this.directionX = directionX;
                    this.directionY = directionY;
                    this.size = size;
                    this.color = color;
                }
                draw() {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2, false);
                    ctx.fillStyle = 'rgba(200, 215, 255, 0.6)';
                    ctx.fill();
                }
                update() {
                    if (this.x > canvas.width || this.x < 0) {
                        this.directionX = -this.directionX;
                    }
                    if (this.y > canvas.height || this.y < 0) {
                        this.directionY = -this.directionY;
                    }
                    this.x += this.directionX;
                    this.y += this.directionY;
                    this.draw();
                }
            }

            function initCanvas() {
                particlesArray = [];
                let numberOfParticles = (canvas.height * canvas.width) / 9000;
                for (let i = 0; i < numberOfParticles; i++) {
                    let size = (Math.random() * 3) + 1;
                    let x = (Math.random() * ((innerWidth - size * 2) - (size * 2)) + size * 2);
                    let y = (Math.random() * ((innerHeight - size * 2) - (size * 2)) + size * 2);
                    let directionX = (Math.random() * 0.4) - 0.2;
                    let directionY = (Math.random() * 0.4) - 0.2;
                    let color = '#8C9EFF';
                    particlesArray.push(new Particle(x, y, directionX, directionY, size, color));
                }
            }

            function connect() {
                let opacityValue = 1;
                for (let a = 0; a < particlesArray.length; a++) {
                    for (let b = a; b < particlesArray.length; b++) {
                        let distance = ((particlesArray[a].x - particlesArray[b].x) * (particlesArray[a].x - particlesArray[b].x))
                                        + ((particlesArray[a].y - particlesArray[b].y) * (particlesArray[a].y - particlesArray[b].y));
                        if (distance < (canvas.width/7) * (canvas.height/7)) {
                            opacityValue = 1 - (distance/20000);
                            let dx = mouse.x - particlesArray[a].x;
                            let dy = mouse.y - particlesArray[a].y;
                            let mouseDistance = Math.sqrt(dx*dx + dy*dy);
                            if (mouseDistance < mouse.radius) {
                                ctx.strokeStyle = `rgba(220, 230, 255, ${opacityValue})`;
                            } else {
                                ctx.strokeStyle = `rgba(200, 215, 255, ${opacityValue * 0.3})`;
                            }
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.moveTo(particlesArray[a].x, particlesArray[a].y);
                            ctx.lineTo(particlesArray[b].x, particlesArray[b].y);
                            ctx.stroke();
                        }
                    }
                }
            }

            function animate() {
                requestAnimationFrame(animate);
                ctx.clearRect(0, 0, innerWidth, innerHeight);
                ctx.fillStyle = '#111827';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                for (let i = 0; i < particlesArray.length; i++) {
                    particlesArray[i].update();
                }
                connect();
            }
            
            window.addEventListener('resize', () => {
                canvas.width = innerWidth;
                canvas.height = innerHeight;
                mouse.radius = ((canvas.height/120) * (canvas.width/120));
                initCanvas();
            });

            window.addEventListener('mouseout', () => {
                mouse.x = undefined;
                mouse.y = undefined;
            });

            initCanvas();
            animate();
        });

        function copyToClipboard(elementId) {
            const element = document.getElementById(elementId);
            const textToCopy = element.innerText || element.textContent;
            const textArea = document.createElement('textarea');
            textArea.value = textToCopy;
            textArea.style.position = 'absolute';
            textArea.style.left = '-9999px';
            textArea.setAttribute('readonly', '');
            document.body.appendChild(textArea);
            textArea.select();
            try {
                document.execCommand('copy');
                showMessageBox('Copied to clipboard!', 'success');
            } catch (err) {
                console.error('Failed to copy text: ', err);
                showMessageBox('Failed to copy text. Please try manually.', 'error');
            }
            document.body.removeChild(textArea);
        }

        function generateDocx() {
            if (lastGeneratedQuestions.length === 0) {
                showMessageBox("Please generate some questions first!", 'error');
                return;
            }

            const doc = new docx.Document({
                sections: [{
                    properties: {},
                    children: lastGeneratedQuestions.flatMap((q, index) => {
                        const lines = q.split('\n');
                        const children = [];
                        
                        children.push(new docx.Paragraph({
                            text: `Question ${index + 1}`,
                            heading: docx.HeadingLevel.HEADING_1,
                            spacing: { after: 200 }
                        }));
                        
                        lines.slice(2).forEach(line => {
                            if (line.trim() !== '') {
                                children.push(new docx.Paragraph({ text: line }));
                            }
                        });
                        
                        if (index < lastGeneratedQuestions.length - 1) {
                            children.push(new docx.Paragraph({ children: [new docx.PageBreak()] }));
                        }

                        return children;
                    }),
                }],
            });

            docx.Packer.toBlob(doc).then(blob => {
                saveAs(blob, "citex-questions.docx");
            });
        }

    </script>
</body>
</html>

